<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake â€” Playable Single-File Game</title>

  <!-- Fun font -->
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1: #0f1724;
      --panel: rgba(255,255,255,0.06);
      --accent: #00d1b2;
      --muted: #9aa7b2;
      --danger: #ff6b6b;
      --glass: rgba(255,255,255,0.04);
      --radius: 14px;
    }

    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg, #071122 0%, #0f1724 70%);
      font-family: "Nunito", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      color:#e6f0f2;
      -webkit-font-smoothing:antialiased;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }

    .wrap{
      width:100%;
      max-width:980px;
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:20px;
      align-items:start;
    }

    header{
      grid-column:1 / -1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-bottom:6px;
    }

    h1{
      margin:0;
      font-weight:700;
      letter-spacing:-0.5px;
      font-size:1.25rem;
      color:var(--accent);
    }

    .subtitle{
      color:var(--muted);
      font-size:0.95rem;
    }

    /* Game panel */
    .game-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border-radius: var(--radius);
      padding:16px;
      border:1px solid rgba(255,255,255,0.04);
      box-shadow: 0 10px 30px rgba(2,6,12,0.6);
    }

    .canvas-wrap{
      display:flex;
      justify-content:center;
      align-items:center;
      background:var(--glass);
      border-radius:12px;
      padding:12px;
    }

    canvas{
      display:block;
      width:100%;
      max-width:720px;
      height:auto;
      background: linear-gradient(180deg,#071226,#092034);
      border-radius:8px;
      box-shadow: inset 0 20px 40px rgba(0,0,0,0.4);
    }

    /* Sidebar */
    .side-panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:16px;
      border:1px solid rgba(255,255,255,0.03);
      min-height: 320px;
    }

    .stat{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px;
      margin-bottom:8px;
      border-radius:10px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
    }
    .stat strong{ color:#fff; font-size:1.05rem; }

    .controls{
      display:flex;
      gap:8px;
      margin-top:12px;
      flex-wrap:wrap;
    }

    button{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:#eaf6f0;
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      transition:transform .08s ease, background .12s;
    }
    button:hover{ transform:translateY(-2px); background: rgba(0,0,0,0.2); }
    button:active{ transform:translateY(0); }

    .danger{ border-color: rgba(255,107,107,0.3); color:var(--danger); }
    .accent{ border-color: rgba(0,209,178,0.15); color:var(--accent); }

    /* Touch controls - mobile */
    .touch-controls{
      display:grid;
      grid-template-columns: 64px 64px 64px;
      justify-content:center;
      gap:8px;
      margin-top:14px;
      user-select:none;
    }

    .tbtn{
      width:64px;
      height:64px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.03);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.04);
      font-size:1.1rem;
      color:var(--muted);
    }

    .tbtn:active{ transform:scale(.98); }

    .footer-note{ color:var(--muted); font-size:0.9rem; margin-top:12px; }

    @media (max-width:980px){
      .wrap{ grid-template-columns: 1fr; }
      canvas{ max-width:100%; height:360px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Snake â€” Classic Arcade</h1>
        <div class="subtitle">Use Arrow keys or WASD. Tap the on-screen buttons on mobile. Ready, Rapscallion?</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button id="pauseBtn" class="accent">Pause</button>
        <button id="restartBtn">Restart</button>
      </div>
    </header>

    <!-- Game area -->
    <section class="game-card">
      <div class="canvas-wrap">
        <canvas id="gameCanvas" width="720" height="540" aria-label="Snake game canvas"></canvas>
      </div>
      <div class="footer-note">Eat the fruit, grow the snake â€” don't bite yourself. ðŸ˜‰</div>
    </section>

    <!-- Sidebar -->
    <aside class="side-panel">
      <div class="stat"><span>Score</span><strong id="score">0</strong></div>
      <div class="stat"><span>High Score</span><strong id="highScore">0</strong></div>
      <div class="stat"><span>Length</span><strong id="length">1</strong></div>

      <div style="margin-top:8px;color:var(--muted);font-size:0.95rem;">
        Controls
        <ul style="margin:8px 0 0 18px;color:var(--muted)">
          <li>Arrow keys / WASD</li>
          <li>On-screen buttons / swipe (mobile)</li>
          <li>Pause / Restart buttons above</li>
        </ul>
      </div>

      <div style="margin-top:12px;">
        <div style="font-weight:700;margin-bottom:6px;color:#fff">Speed</div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button data-speed="6">Slow</button>
          <button data-speed="10" class="accent">Normal</button>
          <button data-speed="14">Fast</button>
        </div>
      </div>

      <!-- touch controls -->
      <div style="margin-top:14px;">
        <div style="font-weight:700;margin-bottom:6px;color:#fff">Touch Controls</div>
        <div class="touch-controls" id="touchControls" role="group" aria-label="Touch controls">
          <div></div>
          <div class="tbtn" data-dir="up">â–²</div>
          <div></div>
          <div class="tbtn" data-dir="left">â—€</div>
          <div class="tbtn" data-dir="down">â–¼</div>
          <div class="tbtn" data-dir="right">â–¶</div>
        </div>
      </div>

      <div style="margin-top:14px;" class="links">
        <button id="shareBtn">Share Score</button>
        <button id="muteBtn">Toggle Sound</button>
      </div>

      <div style="margin-top:12px;color:var(--muted);font-size:0.88rem">
        Tip: Try to cut corners smoothly â€” patience wins the game.
      </div>
    </aside>
  </div>

  <script>
  /* Snake game â€” single file
     Features:
      - Grid-based snake on canvas
      - Keyboard control (arrow keys + WASD)
      - Touch buttons and swipe support
      - Pause, restart, speed selection
      - Score and high score in localStorage
      - Mobile responsive
  */

  (function(){
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', {alpha:false});
    // Logical grid size (cells)
    const COLS = 30;
    const ROWS = 22;
    // cell size computed from canvas pixel dimensions
    const cellW = Math.floor(canvas.width / COLS);
    const cellH = Math.floor(canvas.height / ROWS);

    // UI elements
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const lengthEl = document.getElementById('length');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const speedButtons = document.querySelectorAll('[data-speed]');
    const muteBtn = document.getElementById('muteBtn');
    const shareBtn = document.getElementById('shareBtn');

    let speed = 10; // moves per second
    let moveInterval = 1000 / speed;
    let lastTime = 0;
    let paused = false;
    let muted = false;

    // Sound (tiny beeps)
    const audioCtx = (window.AudioContext || window.webkitAudioContext) && new (window.AudioContext || window.webkitAudioContext)();
    function beep(vol=0.05, freq=440, duration=0.05){
      if(muted || !audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); }, duration*1000);
    }

    // Game state
    let snake;
    let dir;
    let nextDir;
    let food;
    let score;
    let highScore = parseInt(localStorage.getItem('snake_highscore') || '0', 10) || 0;
    highScoreEl.textContent = highScore;

    function reset(initialSpeed){
      speed = initialSpeed || speed;
      moveInterval = 1000 / speed;
      paused = false;
      snake = [ {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)} ];
      dir = {x:1, y:0}; // start moving right
      nextDir = {x:1, y:0};
      placeFood();
      score = 0;
      updateUI();
    }

    function placeFood(){
      // simple random free-cell placement
      const occupied = new Set(snake.map(s => s.x + ',' + s.y));
      let tries = 0;
      while(true){
        const fx = Math.floor(Math.random() * COLS);
        const fy = Math.floor(Math.random() * ROWS);
        if(!occupied.has(fx + ',' + fy)) { food = {x:fx, y:fy}; break; }
        if(++tries > 1000) { // fallback
          food = {x:0,y:0}; break;
        }
      }
    }

    function updateUI(){
      scoreEl.textContent = score;
      lengthEl.textContent = snake.length;
      highScoreEl.textContent = highScore;
    }

    function setSpeed(s){
      speed = s;
      moveInterval = 1000 / speed;
    }

    // Collision detection with walls and self
    function isCollision(head){
      if(head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) return true;
      // check with body (except tail if will move)
      for(let i=0;i<snake.length;i++){
        if(snake[i].x === head.x && snake[i].y === head.y) return true;
      }
      return false;
    }

    function step(){
      // apply buffered direction, but disallow 180-degree turns
      if(Math.abs(nextDir.x) !== Math.abs(dir.x) || Math.abs(nextDir.y) !== Math.abs(dir.y)){
        dir = nextDir;
      }

      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // wall collision -> game over
      if(isCollision(head)){
        gameOver();
        return;
      }

      // move snake
      snake.unshift(head);

      // eat food?
      if(head.x === food.x && head.y === food.y){
        score += 10;
        beep(0.06, 880, 0.05);
        placeFood();
        // increase speed slightly every 5 foods (optional)
        // if(score % 50 === 0) { setSpeed(Math.min(22, speed+1)); }
      } else {
        snake.pop(); // normal move
      }

      // update UI
      if(score > highScore){ highScore = score; localStorage.setItem('snake_highscore', String(highScore)); }
      updateUI();
    }

    function gameOver(){
      beep(0.14, 220, 0.12);
      paused = true;
      pauseBtn.textContent = 'Paused';
      // flash overlay
      draw(); // final draw
      // draw game over text
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, canvas.height/2 - 48, canvas.width, 96);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px Nunito, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 6);
      ctx.font = '16px Nunito, sans-serif';
      ctx.fillText('Press Restart or Space to play again', canvas.width/2, canvas.height/2 + 22);
      ctx.restore();
    }

    // drawing functions
    function draw(){
      // background
      ctx.fillStyle = '#071226';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // grid background subtle
      ctx.save();
      ctx.globalAlpha = 0.03;
      ctx.fillStyle = '#ffffff';
      for(let c=0;c<COLS;c++){
        for(let r=0;r<ROWS;r++){
          // alternate slightly to give depth
          if((c + r) % 2 === 0){
            ctx.fillRect(c*cellW, r*cellH, cellW, cellH);
          }
        }
      }
      ctx.restore();

      // draw food
      ctx.fillStyle = '#ff6b6b';
      roundRectFill(food.x*cellW + 2, food.y*cellH + 2, cellW-4, cellH-4, 6);

      // draw snake
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        if(i===0){
          // head gradient
          const g = ctx.createLinearGradient(s.x*cellW, s.y*cellH, s.x*cellW+cellW, s.y*cellH+cellH);
          g.addColorStop(0,'#00d1b2');
          g.addColorStop(1,'#00a896');
          ctx.fillStyle = g;
        } else {
          ctx.fillStyle = i%2===0 ? '#0fbf9b' : '#0aa38b';
        }
        roundRectFill(s.x*cellW + 2, s.y*cellH + 2, cellW-4, cellH-4, 6);
      }
    }

    function roundRectFill(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
      ctx.fill();
    }

    // Game loop with fixed tick rate based on moveInterval
    function loop(ts){
      if(!lastTime) lastTime = ts;
      if(paused){
        lastTime = ts;
        requestAnimationFrame(loop);
        return;
      }

      const elapsed = ts - lastTime;
      if(elapsed >= moveInterval){
        step();
        draw();
        lastTime = ts;
      }
      requestAnimationFrame(loop);
    }

    // Input handling
    const keyMap = {
      37: {x:-1,y:0}, // left
      38: {x:0,y:-1}, // up
      39: {x:1,y:0},  // right
      40: {x:0,y:1},  // down
      65: {x:-1,y:0}, // A
      68: {x:1,y:0},  // D
      87: {x:0,y:-1}, // W
      83: {x:0,y:1}   // S
    };

    window.addEventListener('keydown', (e) => {
      if(e.key === ' '){ // space toggles pause / restart
        e.preventDefault();
        if(paused) { paused = false; pauseBtn.textContent = 'Pause'; }
        else { paused = true; pauseBtn.textContent = 'Paused'; }
        return;
      }
      const k = e.keyCode;
      if(keyMap[k]){
        const nd = keyMap[k];
        // prevent immediate 180-degree turn
        if(Math.abs(nd.x) === Math.abs(dir.x) && Math.abs(nd.y) === Math.abs(dir.y)) return;
        nextDir = nd;
      }
    });

    // buttons
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Paused' : 'Pause';
      if(!paused) { lastTime = performance.now(); }
    });

    restartBtn.addEventListener('click', () => {
      reset(10);
      paused = false;
      pauseBtn.textContent = 'Pause';
      lastTime = performance.now();
      draw();
    });

    speedButtons.forEach(b => {
      b.addEventListener('click', () => {
        const s = parseInt(b.getAttribute('data-speed'),10);
        setSpeed(s);
        // highlight choice visually
        speedButtons.forEach(x => x.classList.remove('accent'));
        b.classList.add('accent');
      });
    });

    // touch buttons
    document.querySelectorAll('.tbtn').forEach(btn => {
      btn.addEventListener('pointerdown', (e) => {
        const d = btn.getAttribute('data-dir');
        if(!d) return;
        const map = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
        const nd = map[d];
        if(Math.abs(nd.x) === Math.abs(dir.x) && Math.abs(nd.y) === Math.abs(dir.y)) return;
        nextDir = nd;
      });
    });

    // swipe detection on canvas for mobile
    (function setupSwipe(){
      let touchStart = null;
      canvas.addEventListener('touchstart', (e) => {
        const t = e.touches[0];
        touchStart = {x: t.clientX, y: t.clientY};
      }, {passive:true});
      canvas.addEventListener('touchmove', (e) => {
        if(!touchStart) return;
        const t = e.touches[0];
        const dx = t.clientX - touchStart.x;
        const dy = t.clientY - touchStart.y;
        const absX = Math.abs(dx), absY = Math.abs(dy);
        if(Math.max(absX, absY) > 30){
          if(absX > absY){
            nextDir = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
          } else {
            nextDir = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
          }
          touchStart = null;
        }
      }, {passive:true});
      canvas.addEventListener('touchend', ()=>{ touchStart = null; });
    })();

    // share and mute
    muteBtn.addEventListener('click', ()=>{ muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Toggle Sound'; });
    shareBtn.addEventListener('click', async () => {
      const text = `I scored ${score} on Snake! Can you beat me?`;
      if(navigator.share){
        try { await navigator.share({title:'Snake score', text}); } catch(e) { /* ignore */ }
      } else {
        try { await navigator.clipboard.writeText(text); alert('Score copied to clipboard!'); } catch(e){ alert(text); }
      }
    });

    // initialize and start
    reset(10);
    draw();
    requestAnimationFrame(loop);

    // Start with active focus so keypress works in some mobile browsers
    window.focus();

    // allow space / enter on Restart button to restart when game over
    window.addEventListener('keydown', (e) => {
      if(e.code === 'Space' && paused){
        // if paused because of game over overlay, restart instead
        // We'll treat Space as resume if not game over; if game over, Restart.
        // Simple heuristic: if snake length is 1 and score==0, start fresh
        if(snake.length <= 1 && score === 0){
          reset(10);
        } else {
          paused = !paused;
          pauseBtn.textContent = paused ? 'Paused' : 'Pause';
        }
      }
    });
  })();
  </script>
</body>
</html>
